<html>
	<script type="text/javascript" src="jquery-1.8.1.min.js"></script>
	<script type="text/javascript" src="Bear.js"></script>
	<script type="text/javascript" src="Block.js"></script>
	<script type="text/javascript" src="DialogueBox.js"></script>
	<script type="text/javascript" src="Door.js"></script>
	<script type="text/javascript" src="Key.js"></script>
	<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
	<head>
		<style>
		.starting-canvas {
			border: 4px solid black;
			margin: 0;
		    position: absolute;
		    top: 50%;
		    left: 50%;
		    transform: translate(-50%, -50%);
		}

		.starting-canvas:hover {
			background-color: #550000;
		}

		.centered {
			position: absolute;
		    top: 50%;
		    left: 50%;
		    transform: translate(-50%, -50%);
		}
		body {
			background-color: #660000;
		}
		@font-face {
		  	font-family: "TitleFont";
		  	src: url("../assets/russia.ttf");
		  }

		  @font-face{
		  	font-family: "Kremlin";
		  	src: local('Kremlin'), url("../assets/kremlin.ttf");
		  }
		</style>
	</head>
	<body>
		<p class="centered" style="font-family: Kremlin; font-size: 18pt; margin-top: -150px;">GLOBAL GAME JAM 2018</p>
		<div id="holder" class="starting-canvas" style="height:  250px; width: 290px; cursor: pointer;">
			<canvas id="GameCanvas" width="200" height="300"></canvas>
			<p style="font-family: Kremlin; text-align:center; font-size: 36pt; position: relative; top: -250px; pointer-events:none;" id="preloader"><i class="fa fa-cog fa-spin fa-fw"></i></p>
		</div>
		<p class="centered" style="text-align: center; font-family: Kremlin; font-size: 18pt; margin-top: 205px;">KYLE THOMPSON <br/> JILL CEFALO <br/> KEVIN THOMPSON <br/> <br/> <i style="font-family:serif;" class="fas fa-gamepad"></i> &nbsp; GAMEPAD REQUIRED</p>
		<script>
			var canvas = document.getElementById("GameCanvas");
			var graphics = canvas.getContext("2d");

			

			//Store all images used in the game
			var loadedCount = 0;
			var images = new Array();
			var imageCount = 16;
			var checkLoadHandler;
			function preload() {
				for (i = 0; i < preload.arguments.length; i++) {
					images[i] = new Image();
					images[i].src = preload.arguments[i];
					images[i].onload = function() {
						loadedCount++;
					}
				}
				checkLoadHandler = setInterval(checkIfLoaded, 100);
			}
			preload("../assets/opening.png",
							"../assets/room.png",
							"../assets/opening bear 1.png",
							"../assets/opening bear 2.png",
							"../assets/opening bear 3.png",
							"../assets/transmitter.png",
							"../assets/background.png",
							"../assets/arrow.png",
							"../assets/bear.png",
							"../assets/sit.png",
							"../assets/crouch.png",
							"../assets/clinging.png",
							"../assets/hat.png",
							"../assets/key.png",
							"../assets/door.png",
							"../assets/switch.png");

			

			function checkIfLoaded()
			{
				console.log(loadedCount);
				if(loadedCount == imageCount)
				{
					document.getElementById("preloader").innerHTML = "CommencE";
					canvas.addEventListener("click",fullscreen);
					clearInterval(checkLoadHandler);
				}
			}
			


			var screenWH = screen.width/2;
			var screenHH = screen.height/2;
			var camera = {x: screenWH, y:screenHH, scale: 0.5};
			
			

			var defaultFloor = 1087; 

			var dialogue = new DialogueBox(screenWH/2, screenHH * 1.5);
			dialogue.addLine("Greetings, Komrade. It is time you",
							 "learn to truly serve your country.", 
							 "Guard this transmission well.", 0);

			var loop; //Holds the game loop

			//Gamepad input trackers
			var aPressed = false;
			var xPressed = false;
			var lTrigger = false;
			var rightStickXMoved = false;
			var rightStickYMoved = false;

			var arrDiff = 0;
			var arrDir = 1;
			var initBlockTotal = 0;

			var arrow = new Indicator(-50, -50);
			var map = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
			[0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],						
			[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
			[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,[0],0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
			[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0]];



			//A list containing all the bears currently within the player's control
			var bears = [];
			var blocks = [];
			var keys = [];

			//The index in bears[] of the bear the player is currently controlling
			var active = 0;

			//Send the game into fullscreen and start the game
			function fullscreen(){
				var canvas = document.getElementById("GameCanvas");
				document.getElementById("holder").style.cursor = "default";
				graphics.fillStyle = "black";
				graphics.fillRect(0,0,screen.width, screen.height);
				//Use whatever fullscreen method the current browser uses
			    if(canvas.webkitRequestFullScreen) {
			        canvas.webkitRequestFullScreen();
			    } else {
			        canvas.mozRequestFullScreen();
			    }            

			    //Reset the canvas size
			    canvas.width  = screen.width;
				canvas.height = screen.height;



				canvas.removeEventListener("click", fullscreen);

				loadMainMenu();
			}

			//End the fullscreen and restore the original canvas size
			function endfullscreen(){
				var canvas = document.getElementById("GameCanvas");

				if(document.cancelFullScreen) {
					document.cancelFullScreen();
				} else if (document.mozCancelFullScreen) {
					document.mozCancelFullScreen();
				} else if (document.webkitCancelFullScreen) {
					document.webkitCancelFullScreen();
				}

				canvas.width = 200;
				canvas.height = 100;

				canvas.addEventListener("click", fullscreen);
			}
			var animCount = 0;
			var animLength = 30;
			var animOffset = 1920;
			var animHeight = 1080;
			
			var tvHandler;

			function loadMainMenu()
			{
				tvHandler = setInterval(animateTV, 100);
			}

			function animateTV(){
				graphics.drawImage(images[0], animOffset * animCount, 0, animOffset, animHeight, 0, 0, animOffset, animHeight);
				animCount++;

				if(animCount == animLength)
				{
					animCount = 0;
					animLength = 3;
					clearInterval(tvHandler);
					livingRoom();
					livingRoomHandler = setInterval(livingRoom, 300);
				}
			}

			var roomBackground = images[1]

			var livingRoomHandler;

			var layingBear = images[2];

			var layingBearLength = 2;
			var layingBearCount = 0;
			var layingBearOffset = 626;
			var layingBearHeight = 265;

			var paperBear = images[3];

			var paperBearWidth = 330;
			var paperBearHeight = 552;

			var pipeBear = images[4];

			var pipeBearLength = 4;
			var pipeBearCount = 0;
			var pipeBearOffset = 399;
			var pipeBearHeight = 596;

			var transmitter = images[5];

			var transmitterLength = 7;
			var transmitterCount = 0;
			var transmitting = false;
			var transmitterOffset = 244;
			var transmitterHeight = 205;

			var StartButton = 
			{
				x: 100,
				y: 200,
				text: "Start Game",
				selected: false,
				draw: function(){
					graphics.fillStyle = "#131313";
					graphics.fillRect(this.x, this.y, 300, 100);
					graphics.font = "30pt TitleFont";
					graphics.shadowOffsetY = 5;
					graphics.shadowColor = "#151712";
					graphics.fillStyle = "#849254";
					graphics.fillText(text, x + 25, y + 70);
					graphics.shadowOffsetY = 0;
				}
			};

			StartButton.addEventListener("click", startGame);

			StartButton.selected = true;

			function livingRoom() {
				graphics.drawImage(roomBackground, animOffset * animCount, 0, animOffset, animHeight, 0, 0, animOffset, animHeight);
				animCount++;
				graphics.drawImage(layingBear, layingBearOffset * layingBearCount, 0, layingBearOffset, layingBearHeight, 388-layingBearOffset/2, 884-layingBearHeight/2,layingBearOffset, layingBearHeight);
				graphics.drawImage(pipeBear, pipeBearOffset * pipeBearCount, 0, pipeBearOffset, pipeBearHeight, 1588-pipeBearOffset/2, 676-pipeBearHeight/2, pipeBearOffset, pipeBearHeight);
				layingBearCount++;
				pipeBearCount++;
				graphics.drawImage(paperBear, 804-paperBearWidth/2, 572-paperBearHeight/2, paperBearWidth, paperBearHeight);

				graphics.drawImage(transmitter, transmitterOffset * transmitterCount, 0, transmitterOffset, transmitterHeight, 1048-transmitterOffset/2, 676-transmitterHeight/2, transmitterOffset, transmitterHeight);

				StartButton.draw();

				if(transmitting)
					transmitterCount++;

				if(layingBearCount == layingBearLength)
					layingBearCount = 0;
				if(pipeBearCount == pipeBearLength)
					pipeBearCount = 0;
				if(animCount == animLength)
					animCount = 0;
				if(transmitterCount == transmitterLength)
					transmitterCount = 0;
			}

			var intervalCount = 0;
			//Set initial values when booting the game
			function startGame()
			{
				canvas.style.cursor = "none";

				//Set up controller input
				if(canGame())
				{
					$(window).on("gamepadconnected", function() {
		                hasGP = true;
		                if(intervalCount == 0)
		                	setInterval(gpInput,16);
		                intervalCount++;
		            });
		 
		            $(window).on("gamepaddisconnected", function() {
		                hasGP = false;
		                clearInterval(gpInput);
		            });
		 
		            //setup an interval for Chrome
		            var checkGP = window.setInterval(function() {
		                if(navigator.getGamepads()[0]) {
		                    if(!hasGP) $(window).trigger("gamepadconnected");
		                    window.clearInterval(checkGP);
		                }
		            }, 500);
		        }


		        //Load the tile based map for the level
		        for(var i = 0;i<map.length;i++)
		        {
		        	for (var j = 0;j<map[0].length;j++)
		        	{
		        		if(map[i][j] == 1)
		        		{
		        			var b = new Block(j*75, i*75, j, i, blocks.length, map[i][j] - 1);
		        			blocks.push(b);
		        		}
		        		if(map[i][j] == 2)
		        		{
		        			var d = new Door(j*75, i*75, j, i ,blocks.length);
		        			blocks.push(d);
		        		}
		        		if(map[i][j] instanceof Array)
		        		{
		        			var k = new Key(j*75, i*75, map[i][j], keys.length);
		        			keys.push(k);
		        		}
		        	}
		        }

		        initBlockTotal = blocks.length;
		        //Add a temporary bear
				bears.push(new Bear(25, 400, blocks.length));

				bears.push(new Bear(125, 400, blocks.length + 1));

				bears.push(new Bear(225, 400, blocks.length + 2));

		        //Start the game loop
		        loop = setInterval(gameUpdate, 16);
			}

			//Checks for gamepad input
			function gpInput()
			{

				if(hasGP)
				{
					var gamePad = navigator.getGamepads()[0];
					var leftStickX = gamePad.axes[0];
					var leftStickY = gamePad.axes[1];

					var rightStickX = gamePad.axes[2];
					var rightStickY = gamePad.axes[3];

					var bear = bears[active];

					//Hat Mechanic
					if(!lTrigger && bear.onGround && gamePad.buttons[6].pressed && bear.stackCount == 0 && !bear.stacked && (bear.state == "idle" || bear.state == "walking"))
					{
						lTrigger = true;
						bear.toHat();
					}

					if(lTrigger && !gamePad.buttons[6].pressed)
					{
						bear.toBear();
						lTrigger = false;
					}

					if(Math.abs(leftStickX) > 0.2){
						bear.move((leftStickX/Math.abs(leftStickX)) * 10);
						if(bear.state != "crouching" && bear.state != "clinging")
						{
							if(bear.onGround)
								bear.state = "walking";
							else
								bear.state = "idle";
						}
					}else if (bear.state == "walking"){
						bear.state = "idle";
					}
					if(gamePad.buttons[0].pressed && !aPressed){
						bear.jump();
						aPressed = true;
					}else if(!gamePad.buttons[0].pressed){
						aPressed = false;
					}

					//Stop clinging
					if(leftStickY > 0.9 && bear.state == "clinging")
					{
						bear.state = "idle";
						bear.y += 5;
						bear.floor = defaultFloor;
					}
					

					//Crouching
					if(gamePad.buttons[2].pressed && !xPressed){
						if(bear.state == "crouching"){
							bear.uncrouch();
						}
						else{
							bear.crouch(leftStickX);
						}
						xPressed = true;
					}else if(!gamePad.buttons[2].pressed){
						xPressed = false;
					}

					var closestInd = -1;
					if(bears[active].onGround && bears[active].state != "clinging" && !bears[active].isHat)
					{
						if(Math.abs(rightStickX) > 0.9 && !rightStickXMoved && Math.abs(rightStickY) < 0.9){
							rightStickXMoved = true;
							
							var closestCandidates = findClosestX(rightStickX, bears, bears[active]);

							if(closestCandidates.length == 1){
								active = closestCandidates[0];
							}else{
								var newClosestCandidates = [];
								for (var j = 0;j<closestCandidates.length;j++)
									newClosestCandidates.push(bears[closestCandidates[j]]);
								var nextClosestCandidates = findClosestX(rightStickX, newClosestCandidates, bears[active]);
								if(nextClosestCandidates.length >= 1)
									active = nextClosestCandidates[0];
							}

						}else if(Math.abs(rightStickX) < 0.9 && rightStickXMoved) {
							rightStickXMoved = false;
						}else if(Math.abs(rightStickY) > 0.9 && !rightStickYMoved  && Math.abs(rightStickX) < 0.9){
							rightStickYMoved = true;
							
							var closestCandidates = findClosestY(rightStickY, bears, bears[active]);

							if(closestCandidates.length == 1){
								active = closestCandidates[0];
							}else{
								var newClosestCandidates = [];
								for (var j = 0;j<closestCandidates.length;j++)
									newClosestCandidates.push(bears[closestCandidates[j]]);
								var nextClosestCandidates = findClosestX(rightStickX, newClosestCandidates, bears[active]);
								if(nextClosestCandidates.length >= 1)
									active = nextClosestCandidates[0];
							}

						}else if(Math.abs(rightStickY) < 0.9 && rightStickYMoved) {
							rightStickYMoved = false;
						}
					}
				}
			}
 			
 			//Helper functions for selecting the active bear
 			function findClosestX(val, arr, activeBear)
 			{	
 				var closestInds = [];
 					if(val < 0)
					{
						var closestX = -Number.MAX_SAFE_INTEGER;
						for(var i = 0; i< arr.length; i++)
						{
							if(arr[i]!=activeBear && arr[i].x <= activeBear.x && arr[i].x >= closestX && !arr[i].stacked)
							{
								if(arr[i].x > closestX)
									closestInds = [];
								closestX = arr[i].x;
								closestInds.push(i);
							}
						}
					} else {
						var closestX = Number.MAX_SAFE_INTEGER;
						for(var i = 0; i< arr.length; i++)
						{
							if(arr[i]!=activeBear && arr[i].x >= activeBear.x && arr[i].x <= closestX && !arr[i].stacked)
							{
								if(arr[i].x < closestX)
									closestInds = [];
								closestX = arr[i].x;
								closestInds.push(i);
							}
						}
					}
					if(closestInds.length != 1)
						return closestInds;
					else{
						closestInd = closestInds[0];	
						return [closestInds[0]];
					}
 			}

 			//Helper functions for selecting the active bear
 			function findClosestY(val, arr, activeBear)
 			{	
 				var closestInds = [];
 					if(val < 0)
					{
						var closestY = -Number.MAX_SAFE_INTEGER;
						for(var i = 0; i< arr.length; i++)
						{
							if(arr[i]!=activeBear && arr[i].y <= activeBear.y && arr[i].y >= closestY && !arr[i].stacked)
							{
								if(arr[i].y > closestY)
									closestInds = [];
								closestY = arr[i].y;
								closestInds.push(i);
							}
						}
					} else {
						var closestY = Number.MAX_SAFE_INTEGER;
						for(var i = 0; i< arr.length; i++)
						{
							if(arr[i]!=activeBear && arr[i].y >= activeBear.y && arr[i].y <= closestY && !arr[i].stacked)
							{
								if(arr[i].y < closestY)
									closestInds = [];
								closestY = arr[i].y;
								closestInds.push(i);
							}
						}
					}
					if(closestInds.length != 1)
						return closestInds;
					else{
						closestInd = closestInds[0];	
						return [closestInds[0]];
					}
 			}


 			//Check if there's a controller connected
			function canGame() {
		        return "getGamepads" in navigator;
		    }

		    function gameUpdate() {
		    	camera.x+=Math.ceil((bears[active].x-camera.x)/8);
		    	camera.y+=Math.ceil(((bears[active].y - bears[active].height * bears[active].stackCount/2)-camera.y)/8);

		    	for(var i = 0;i<bears.length; i++)
		    		bears[i].update();

					for(var j = 0;j<bears.length;j++){
		    			if(j != active)
		    				bears[j].checkCollision(bears[active]);
		    		}

		    	for(var b = 0;b<blocks.length; b++)
		    	{
		    		blocks[b].update();
		    		for(var r = 0; r< bears.length; r++)
		    			blocks[b].checkCollision(bears[r]);
		    	}

		    	for(var k = 0;k<keys.length; k++)
		    		keys[k].update();

		    	var max = maxCamDistance(bears);
		    	if(max[0] > screenWH)
		    		camera.scale = screenWH/max[1];
		    	else if(max[0] < 400 && (400)/max[1] < 1.5)
		    		camera.scale = (400)/max[1];
		    	arrow.update();
		    	dialogue.update();
		    	gameDraw();
		    }


		    var background = images[6];
		    function gameDraw() {
		    	graphics.drawImage(background, 0,0,canvas.width,canvas.height);
		    	graphics.fillStyle = "#686868";
		    	graphics.font = '30px TitleFont';
		    	for(var i = 0;i<bears.length; i++){
		    		if(!bears[i].stacked)
		    			bears[i].draw();
		    	}
		    	for(i = 0;i<blocks.length;i++)
		    		blocks[i].draw();
		    	arrow.draw();
		    	dialogue.draw();

		    	for(i = 0; i<keys.length;i++)
		    		keys[i].draw();
		    }


			

			function Indicator(x, y) {
				this.x = x;
				this.y = y;



				this.pic = images[7];

				this.moveTo = function(newX,newY) {
					this.x = newX;
					this.y = newY;
				}

				this.draw = function(){
					graphics.save();
					graphics.scale(camera.scale, camera.scale);
					graphics.drawImage(this.pic, this.x - 25 - camera.x + screenWH * 1/camera.scale, this.y + arrDiff - 25 - camera.y  + screenHH * 1/camera.scale, 50, 50);
					graphics.restore();
				}

				this.update = function() {

					arrDiff += arrDir/3;
					if(Math.abs(arrDiff) > 4)
						arrDir *= -1;

					this.moveTo(bears[active].x, bears[active].y + (arrDiff * arrDiff) - bears[active].height/2 - (bears[active].height/2) * bears[active].stackCount - 50);

					if(bears[active].state == "clinging" && bears[active].grav == 0)
						this.y -= 50;
				}
			}

			function isInFrame(x,y) {
				var camCoordX = (x - camera.x) * camera.scale;
				var camCoordY = (y - camera.y) * camera.scale;

				return ((camCoordX > -screenWH&& camCoordX < screenWH) && (camCoordY > -screenHH && camCoordY < screenHH));
			}

			function maxCamDistance(arr)
			{
				var maxDist = 0;
				var real= 0;
				for(i = 0;i<arr.length;i++)
				{
					var camCoordX = (arr[i].x - camera.x);
					var camCoordY = (arr[i].y - camera.y);
					var dist = Math.sqrt(camCoordX * camCoordX + camCoordY * camCoordY);
					if(dist > real)
						real = dist;
					camCoordX *= camera.scale;
					camCoordY *= camera.scale;
					dist = Math.sqrt(camCoordX * camCoordX + camCoordY * camCoordY);
					if(dist > maxDist)
						maxDist = dist;
				}
				return [maxDist, real];
			}
		</script>
	</body>
</html>